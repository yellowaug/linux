spring boot 程序模板
教程URL http://www.spring4all.com/article/246
=========================================================
                    目          录
=========================================================
1.遇到的问题
2.注意事项
3.程序模板
3.1 application.properties模板
3.2 XXXDao.xml 增-删-改-查模板，sql Mapper文件模板
3.3 XXXController模板
3.4 XXXDao接口模板
3.5 Tomcat+spring boot 后端解决跨域问题
3.6 swagger2程序模板
3.7 多数据库连接配置类模板
3.8 Resttempare Https请求模板Resttemplate
3.9 Resttemplate POST，get请求模板
4.打包部署
5.pom.xml模板
=========================================================
遇到的问题
1.swagger2显示API列表会显示出一些无用的接口，如HEAD，OPTIONS,PATH请求方式
2.swagger2默认的启动路径有点长，需要更改
3.swagger2默认启动页面，要修改很麻烦，所以还是用默认的吧
4.在spring-mybatis-Druid配置多连接时，无法创建DAO类或者实体类
5.注意Springboot接口跨域的问题
---------------------------------------------------------
注意事项
---------------------------------------------------------
1.controller包以及controller类必须与XXXApplication类在同一包内，否则框架无法扫描到
例子
src
 |--main
     |--java
         |--com.jjck.xxx
                |
                |--controller
                |--dao
                |--domain
                |service
                XXXApplication.class
                ServletInitializer.class
2.mybatis的Daomapper文件必须放在资源文件夹的目录下，且必须以mapper命名，否则框架服务找到mapper.xml文件
resource
   |--mapper(放mapper映射文件)
   |--static
   |--templates
   application.properties (配置文件，如数据库连接配置，mybatis配置)
3.在controller类中的方法，如需要传入参数，需要注意
  1）Get,DELETE方式在参数中如果没有@PathVariable("id")则会报空指针异常，
  2）POST,PUT方式如同没有@RequestBody则无法读取传入的对象
4.DAO接口文件的名称与Dao映射文件的名称必须一致，否则会报错
5.在入口程序xxxapplication中必须加入@MapperScan("dao包的全限定名称")
实例
@SpringBootApplication
@MapperScan("com.jjck.bootpart3.dao")
public class Bootpart3Application {

    public static void main(String[] args) {
        SpringApplication.run(Bootpart3Application.class, args);
    }

}
6.在使用Swagger2时，最好不要在XXController类前使用@RequestMapping("/api/city")这样的注释，
如果使用会导致Swagger显示包括一个URL的所有请求方式，这样会使得页面杂乱
7.在控制类方法中使用@GetMapping @PostMapping代替@RequestMapping 这样会使页面内容显示有序。
8.swagger2默认路径http://xxx.com/xxx/swagger-ui/index.html
9.在配置spring-mybatis-Druid多数据库时，XXXDAO.xml文件中resultType标签必须是 resultType="实体类的全限定名称"，否则报错
10.Swagger2的配置类名称必须叫Swagger2否则会无法实例化对象，导致页面无法访问
---------------------------------------------------------
程序模板
---------------------------------------------------------
增删改查的业务模板
---------------------------------------------------------
application.properties模板
---------------------------------------------------------
## 数据源配置
spring.datasource.url=jdbc:sqlserver://10.12.3.61:1433;DatabaseName=TestDemo
spring.datasource.username=sa
spring.datasource.password=sa
#spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver
## Mybatis 配置
mybatis.typeAliasesPackage=com.jjck.bootpart3.domain
mybatis.mapperLocations=classpath:mapper/*.xml

redis配置文件模板
# Redis数据库索引（默认为0）
spring.redis.database=0
# Redis服务器地址
spring.redis.host=10.12.3.61
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
#spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0
# 连接超时时间（毫秒）
spring.redis.timeout=0
---------------------------------------------------------
XXXDao.xml 增-删-改-查模板，sql Mapper文件模板
---------------------------------------------------------
<mapper namespace="dao全限定路径">
    <sql id="ColumnList"> 字段集合的写法
        id,province_id, city_name, desc_city
    </sql>
    <select id="dao接口的方法名称" resultType="domainl类">
        select
        <include refid="ColumnList" />
         from city
    </select>
    <insert id="dao接口的方法名称">
        insert into city(
        province_id, city_name, desc_city
        )
        values (#{province_id},#{city_name},#{desc_city})
    </insert>
    <select id="dao接口的方法名称" resultType="City">
        select
        <include refid="ColumnList" />
        from city where id=#{id}
    </select>
    <update id="dao接口的方法名称">
        update city
        set
        <if test="province_id!=null">
             province_id=#{province_id},
        </if>
        <if test="city_name!=null">
            city_name=#{city_name},
        </if>
        <if test="desc_city!=null">
            desc_city=#{desc_city}
        </if>
        where id=#{id}
    </update>
    <delete id="dao接口的方法名称" parameterType="java.lang.Integer">
        delete from city where id=#{id}
    </delete>
</mapper>
---------------------------------------------------------
where标签的用法以及 &gt; 是> | &lt;是<
---------------------------------------------------------
 <select id="serachFormalOrderOfDate" resultType="com.jjck.javamnm.Domain.OldMnm.FormalOrder">
        select top 1000 * from FormalOrder
        <where>
            <if test="orderCode!=null">
                fCode=#{orderCode}
            </if>

            <if test="cusName!=null">
                and fCustName=#{cusName}
            </if>

            <if test="docter!=null">
                and  fDoctor=#{docter}
            </if>

            <if test="patient!=null">
                and fPatient=#{patient}
            </if>

            <if test="orderStartDate!=null">
                and  fDate &gt;=#{orderStartDate}
            </if>
            <if test="orderEndDate != null">
                and fDate &lt;=#{orderEndDate}
            </if>
        </where>
    </select>
---------------------------------------------------------
XXXController模板
---------------------------------------------------------
@RestController                  <---让在框架注册controller类
@RequestMapping("/api/city")    <---URL 映射时，用于绑定请求参数到方法参数
public class CityController {
    @Autowired <---省略GET SET方法
    private CityService cityService;


//    Get,DELETE方法在参数中如果没有@PathVariable("id")则会报空指针异常，

    @RequestMapping(value = "/")
    public List<City> getAllCity(){
        return cityService.getAllCity();
    }
    @RequestMapping(value = "/",method = RequestMethod.POST)
    public String insertCity(@RequestBody City city){

        int code=cityService.insertCity(city);
        ...
        业务代码
        ...
    }
    @RequestMapping("/{id}")
    public City getCity(@PathVariable("id") Integer id){
        return this.cityService.getCity(id);
    }
    @RequestMapping(value = "/",method = RequestMethod.PUT)
    public String upCity(@RequestBody City city){
        int code =cityService.updataCity(city);
        ...
        业务代码
        ...
    }
    @RequestMapping(value = "/{id}",method = RequestMethod.DELETE)
    public String deleteCity(@PathVariable("id") Integer id){
        int code =cityService.deleteCity(id);
        ...
        业务代码
        ...
    }
---------------------------------------------------------
XXXDao接口模板
---------------------------------------------------------
public interface CityDao {

    List<City> getList();
    int insertData(City city);
//    City getSingeData(@Param("id") Integer id);
//    有@Param和没有@Param的区别似乎不大，程序都可以正常执行
    City getSingeData(Integer id);
    int updateData(City city);
    int deleteData(int id);
}
service 接口以及实现模板
public interface CityService {
...
增删改查业务接口
...

}
@Service
public class CityServiceImpl implements CityService {
    @Autowired
    private CityDao cityDao;
...
增删改查的实现方法
...
}
---------------------------------------------------------------------------
Tomcat+spring boot 后端解决跨域问题
解决跨域请求问题，基本上每个后端项目都必须要配置，固定配置文件
另一种解决方式就是在Controller层上面直接加注释@CrossOrigin
Url：https://blog.csdn.net/weixin_42556829/article/details/103890824?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
---------------------------------------------------------------------------
package com.jjck.javamnm.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
/*
允许全局跨域设置
 */

@Configuration
public class CorsConfig {
    private CorsConfiguration buildConfig() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin("*"); //允许任何域名
        corsConfiguration.addAllowedHeader("*"); //允许任何头
        corsConfiguration.addAllowedMethod("*"); //允许任何方法
        return corsConfiguration;
    }
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/*/*", buildConfig()); //注册,注意自己api路径的命名方式
        return new CorsFilter(source);
    }
}

---------------------------------------------------------------------------
swagger2程序模板：
文档地址：
https://developer.ibm.com/zh/articles/j-using-swagger-in-a-spring-boot-project/
---------------------------------------------------------------------------

增加Swagger2类，以下程序整段复制即可
@Configuration
@EnableSwagger2
public class Swagger2 {


    private ApiInfo apiInfo(){
        return new ApiInfoBuilder().title("test resfulapi info")
                .description("test")
                .termsOfServiceUrl("http://127.0.0.1:8080")
                .build();
    }
    @Bean
    public Docket createRestApi(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.jjck.bootpart3.controller"))
                .paths(PathSelectors.any())
                .build();
    }
或者使用这段
@SpringBootApplication
@MapperScan("com.jjck.bootpart3.dao")
@Enableopenapi
public class Bootpart3Application {

    public static void main(String[] args) {
        SpringApplication.run(Bootpart3Application.class, args);
    }

}
在实体类中添加注释：@ApiModel(value = "xxx",description = "Xxx")
实例
@ApiModel(value = "City",description = "城市")
public class City {
    @ApiModelProperty("主键ID")
    private Integer id;
    @ApiModelProperty("城市编号")
    private Integer province_id;
    @ApiModelProperty("城市名称")
    private String city_name;
    @ApiModelProperty("城市描述信息")
    private String desc_city;
}
在控制类中添加注释：
@RequestMapping("/api/city")
public class XXXController{
    @ApiOperation(value = "xxx",notes = "xxx")
    @GetMapping(value = "/")
    public List<City> getAllCity(){  <--------------业务方法
        return cityService.getAllCity();
    }
}
---------------------------------------------------------------------------
多数据库连接配置类模板
文档地址：
---------------------------------------------------------------------------
从库
@Configuration
@MapperScan(basePackages = ClusterDataSourceConfig.PACKAGE,sqlSessionFactoryRef = "clusterSqlSessionFactory")
public class ClusterDataSourceConfig {
    // 精确到 cluster 目录，以便跟其他数据源隔离
    static final String PACKAGE = "com.jjck.mutilsource.dao.cluster";  //包的全限定名称
    static final String MAPPER_LOCATION = "classpath:mapper/cluster/*.xml";  //xml文件的路径
    @Value("${cluster.datasource.url}")
    private String url;

    @Value("${cluster.datasource.username}")
    private String user;

    @Value("${cluster.datasource.password}")
    private String password;

    @Value("${cluster.datasource.driverClassName}")
    private String driverClass;

    @Bean(name = "clusterDataSource")
    public DataSource clusterDataSource(){
        DruidDataSource dataSource=new DruidDataSource();
        dataSource.setDriverClassName(this.driverClass);
        dataSource.setUrl(this.url);
        dataSource.setUsername(this.user);
        dataSource.setPassword(this.password);
        
        return dataSource;
    }
    @Bean(name = "clusterDataSourceTransactionManager")
    public DataSourceTransactionManager clusterDataSourceTransactionManager(){
        return new DataSourceTransactionManager(clusterDataSource());
    }

    @Bean(name = "clusterSqlSessionFactory")
    public SqlSessionFactory clusterSqlSessionFactory(@Qualifier("clusterDataSource") DataSource clusterDataSource)
        throws Exception{
        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(clusterDataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources(ClusterDataSourceConfig.MAPPER_LOCATION));
        return sessionFactory.getObject();
    }
}

主库配置类
@Configuration
@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE,sqlSessionFactoryRef = "masterSqlSessionFactory")
public class MasterDataSourceConfig {
    static final String PACKAGE = "com.jjck.mutilsource.dao.master"; //包的全限定名称
    static final String MAPPER_LOCATION = "classpath:mapper/master/*.xml"; //xml文件的路径
    @Value("${master.datasource.url}")
    private String url;
    @Value("${master.datasource.username}")
    private String user;
    @Value("${master.datasource.password}")
    private String password;
    @Value("${master.datasource.driverClassName}")
    private String driverClass;

    @Bean(name = "masterDataSource")
    @Primary
    public DataSource masterDataSource(){
        DruidDataSource dataSource=new DruidDataSource();
        dataSource.setDriverClassName(this.driverClass);
        dataSource.setUrl(this.url);
        dataSource.setUsername(this.user);
        dataSource.setPassword(this.password);
        return dataSource;
    }
    @Bean(name = "masterTransactionManager")
    @Primary
    public DataSourceTransactionManager masterTransactionManager(){
        return new DataSourceTransactionManager(masterDataSource());
    }
    @Bean(name = "masterSqlSessionFactory")
    @Primary
    public SqlSessionFactory masterSqlSessionFactory(@Qualifier("masterDataSource") DataSource masterDataSource) throws Exception{
        final SqlSessionFactoryBean sessionFactoryBean=new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(masterDataSource);
        sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MasterDataSourceConfig.MAPPER_LOCATION));
        return sessionFactoryBean.getObject();
    }

}
---------------------------------------------------------------------------
Resttempare Https请求模板Resttemplate 固定样式，直接复制粘贴即可
文档地址：https://blog.csdn.net/qq_35115257/article/details/80627386
---------------------------------------------------------------------------
package com.jjck.javamnm.Service.Iot.https;

import org.springframework.http.client.SimpleClientHttpRequestFactory;

import javax.net.ssl.*;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.Socket;

import java.security.cert.X509Certificate;

public class HttpsClientRequestFactory extends SimpleClientHttpRequestFactory {
    @Override
    protected void prepareConnection(HttpURLConnection connection, String httpMethod)  {
        try {
            if (!(connection instanceof HttpsURLConnection)) {
                throw new RuntimeException("An instance of HttpsURLConnection is expected");
            }

            HttpsURLConnection httpsConnection = (HttpsURLConnection) connection;

            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }
                        @Override
                        public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        }
                        @Override
                        public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        }

                    }
            };
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            httpsConnection.setSSLSocketFactory(new MyCustomSSLSocketFactory(sslContext.getSocketFactory()));

            httpsConnection.setHostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String s, SSLSession sslSession) {
                    return true;
                }
            });

            super.prepareConnection(httpsConnection, httpMethod);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    private static class MyCustomSSLSocketFactory extends SSLSocketFactory {
        private final SSLSocketFactory delegate;

        public MyCustomSSLSocketFactory(SSLSocketFactory delegate) {
            this.delegate = delegate;
        }

        // 返回默认启用的密码套件。除非一个列表启用，对SSL连接的握手会使用这些密码套件。
        // 这些默认的服务的最低质量要求保密保护和服务器身份验证
        @Override
        public String[] getDefaultCipherSuites() {
            return delegate.getDefaultCipherSuites();
        }

        // 返回的密码套件可用于SSL连接启用的名字
        @Override
        public String[] getSupportedCipherSuites() {
            return delegate.getSupportedCipherSuites();
        }


        @Override
        public Socket createSocket(final Socket socket, final String host, final int port,
                                   final boolean autoClose) throws IOException {
            final Socket underlyingSocket = delegate.createSocket(socket, host, port, autoClose);
            return overrideProtocol(underlyingSocket);
        }


        @Override
        public Socket createSocket(final String host, final int port) throws IOException {
            final Socket underlyingSocket = delegate.createSocket(host, port);
            return overrideProtocol(underlyingSocket);
        }

        @Override
        public Socket createSocket(final String host, final int port, final InetAddress localAddress,
                                   final int localPort) throws
                IOException {
            final Socket underlyingSocket = delegate.createSocket(host, port, localAddress, localPort);
            return overrideProtocol(underlyingSocket);
        }

        @Override
        public Socket createSocket(final InetAddress host, final int port) throws IOException {
            final Socket underlyingSocket = delegate.createSocket(host, port);
            return overrideProtocol(underlyingSocket);
        }

        @Override
        public Socket createSocket(final InetAddress host, final int port, final InetAddress localAddress,
                                   final int localPort) throws
                IOException {
            final Socket underlyingSocket = delegate.createSocket(host, port, localAddress, localPort);
            return overrideProtocol(underlyingSocket);
        }

        private Socket overrideProtocol(final Socket socket) {
            if (!(socket instanceof SSLSocket)) {
                throw new RuntimeException("An instance of SSLSocket is expected");
            }
            ((SSLSocket) socket).setEnabledProtocols(new String[]{"TLSv1"});
            return socket;
        }
    }

}

---------------------------------------------------------------------------
Resttemplate POST，get请求模板：
文档地址：https://blog.csdn.net/qq_35115257/article/details/80627386
---------------------------------------------------------------------------
 RestTemplate restTemplate=new RestTemplate(new HttpsClientRequestFactory());
        // -------------------------------> 解决(响应数据可能)中文乱码 的问题
        List<HttpMessageConverter<?>> converterList=restTemplate.getMessageConverters();
        converterList.remove(1);// 移除原来的转换器
        // 设置字符编码为utf-8
        HttpMessageConverter<?> converter = new StringHttpMessageConverter(StandardCharsets.UTF_8);
        converterList.add(1, converter);// 添加新的转换器(注:convert顺序错误会导致失败)
        restTemplate.setMessageConverters(converterList);
        String url="https://10.11.10.2/api/v1/accessToken";
        //装载请求头，构建请求内容
        HttpHeaders httpHeaders=new HttpHeaders();
        httpHeaders.setContentType(MediaType.APPLICATION_JSON);
        MultiValueMap<String,String> httpBody=new LinkedMultiValueMap<>();

        httpBody.add("api_token",this.token);
//        httpBody.add("api_token","823936341d68ac379c95c0480563ef4e");
        JSONObject jsonObject=JSONObject.fromObject(httpBody.toSingleValueMap());
//      装载HTTP请求
        HttpEntity<String> request=new HttpEntity<>(jsonObject.toString(),httpHeaders);
        //发起POST请求
        ResponseEntity<String> response=restTemplate.postForEntity(url,request,String.class);
        JSONObject resultJsonObj=JSONObject.fromObject(response.getBody());
---------------------------------------------------------------------------
打包部署
---------------------------------------------------------
IDEA生成war包
url:https://www.jianshu.com/p/0da335cbc581
---------------------------------------------------------

---------------------------------------------------------
pom.xml模板
---------------------------------------------------------
    <!--
    swagger2所需依赖
    https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>3.0.0</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>3.0.0</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/io.springfox/springfox-boot-starter -->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-boot-starter</artifactId>
            <version>3.0.0</version>
        </dependency>


        <!-- redis依赖
        https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
        <version>2.3.4.RELEASE</version>
    </dependency>

        <!-- Spring Boot Mybatis 依赖 -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.2.0</version>
        </dependency>
        <!--多数据源连接依赖
         https://mvnrepository.com/artifact/com.alibaba/druid -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.1</version>
        </dependency>
